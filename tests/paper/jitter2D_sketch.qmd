---
title: "Two dimensional jiterred scatter plot"
format: pdf
number-sections: true
bibliography: references.bib
---

# Introduction

We have included some ideas and examples for Jittered scatter plots in this document.


## Related work

Some alternative plots to deal with over plotting are gather plots [@park2017gatherplots, @park2023gatherplot], also in dimensionality reduction vizualization exploretree plot[@marcilio2021explorertree], and recently integral images to "de-cluttering" scatter plots [@rave2024cluttering]. 

Adding noise in quasi-random way appears in swarm plot [@idrus2021swarm], blue noise plots [@van2021blue], SOM based jittering [@trutschl2003intelligently], or beeswarm plot (REF???). Usually these methods are designed to jitter in one dimension.  

Quasi-random methods has being studied, @christensen2018progressive compare methods for quasirandom genrators in 2D. These methods are used in several scenarios, applied to copulas [@cambou2017quasi] or quasi montecarlo[@ohbuchi1996quasi] 


## Goal and structure
Introduce methods for jittering in 2D and implement an R package that extends `geom_jitter()`

-   Describe some methods/ideas
-   Show application examples
-   Discuss limitations and next steps

# Methods

Combine 2 parameters to describe jittering in 2D, each parameter has two possible levels.

-   Noise: Random (R) or Quasi-random (Q)

-   Direction: Global (G) or Local (L)

Combining the 2 parameters gives 4 ways to jitter scatter plots: R-L, R-G, Q-L, Q-G.

## Adding noise in 2D
Noise is related to how the jittering is generated. Traditionally in 1D, jittering is randomly generated with a uniform distribution. For 2D, random generation can be done based on a bivariate normal distribution. For a given point $(x_i, y_i)$, the first step is to compute initial noise, which is done as:

$$
\begin{pmatrix} e_x \\ e_y \end{pmatrix} \sim N(0 , 
\begin{pmatrix} 1/9 & 0 \\ 0 & 1/9 \end{pmatrix}
)
$$

Alternatively, if there are $r$ observations in the same position, a two-dimensional quasi-random sequence of $r$ points can be used. Several quasi-random schemes have been proposed; in 2D, Sobol sequences seem to be a good choice.

$$
\begin{pmatrix} e_x \\ e_y \end{pmatrix} \sim Sobol(r, dim = 2) 
$$

## Noise direction 
The second step is to rotate the noise according to the observed direction in the data. Direction controls how the observed data influence the jittering; in particular, the correlation structure of the data affects the jittering direction through the correlation coefficient.

$$
\begin{pmatrix} \Delta_x \\ \Delta_y \end{pmatrix} = \mbox{chol} \left[  \begin{pmatrix} 1 & \rho_{xy} \\ \rho_{xy} & 1 \end{pmatrix}  \right]^{\top} \begin{pmatrix} e_x & e_y \end{pmatrix} 
$$

where $\mbox{chol}[]$ stands for Cholesky decomposition. (is this having an effect on variance too??)

Correlation, $\rho_{xy}$, can be computed using all points (global) or with the closer points to the one being jittered (local). A local correlation can be computed using only neighbors or using kernel weights.

## Jittering separation (not done!)
A third parameter that might be worth adding is Voronoi constraint. When Voronoi is TRUE, jittered points are forced to lie within the Voronoi cell of the corresponding observed point. This ensures the resulting jittered plot does not overlap and naturally controls the amount of jittering. (**Not sure how hard or if this is possible to do!!**)

# Application examples

```{r functions}
#| message: false
#| echo: false 
#| warning: false 

library(tidyverse)
library(patchwork)
library(stringr)
library(here)
source(here('tests/sandbox/utils.R') )
devtools::load_all()

exapmle_fn <- function(genff, nn) {
  df <- genff(n = nn)
  dfr <- df |> mutate(x = round(x), y = round(y))
  pp <- vector(mode = 'list', length = 6)

  pp[[1]] <- df
  pp[[2]] <- dfr
  pr <- expand.grid(n = c('random', 'quasi'), d = c('local', 'global'))
  for (p in 1:4) {
    pp[[p + 2]] <- compute_jitter2D(dfr, noise = pr$n[p], dir = pr$d[p])
  }

  pr_nm <- pr |>
    mutate(
      p = c(2, 3, 5, 6),
      n = str_sub(n, 1, 1) |> toupper(),
      d = str_sub(d, 1, 1) |> toupper()
    ) |>
    unite('ll', n, d, sep = '-') |>
    unite('ll', p, ll, sep = ':') |>
    pull(ll)

  names(pp) <- c('1:Original', '4:Rounded', pr_nm)
  dd <- bind_rows(pp, .id = 'type')

  ggplot(dd, mapping = aes(x, y)) +
    geom_point() +
    facet_wrap(~type) +
    theme_bw() +
    theme(aspect.ratio = 1, axis.text = element_blank()) +
    labs(x = '', y = '')
}
```

## Toy examples

Each figure is a type of data plot to explore jittering under different data characteristics. There are 6 panels: the original data, the rounded data, and 4 jittered versions (random-local, random-global, quasi-local, quasi-global).

@fig-dayles shows jittering in the Dayles data, where the original and rounded versions are very similar. The quasi-random options are nice since they do not jitter when there is a single point. It is possible to set the random options with the same behavior, jittering only the second point in a position.

```{r}
#| label: fig-dayles
#| message: false
#| echo: false 
#| warning: false 
#| fig-cap: "Dayles data: ash vs beg"
exapmle_fn(genff = gendt_dayles, nn = 100)
```

@fig-mpg shows the mpg data, which is the example used in the regular `geom_jitter()` page. This may not be a good example for 2D jittering since one of the variables is not really numerical. In any case, the global correlation methods show lower variability (why?) and some data structure, while there is no correlation when local methods are used.

```{r}
#| label: fig-mpg
#| message: false
#| echo: false 
#| warning: false  
#| fig-cap: "mpg data (example in geom_jitter() )"
#| 
exapmle_fn(genff = gendt_mpg, nn = 100)
```

@fig-bimodal shows bimodal data, where the rounded data show a lot of overplotting. Using local correlations seems to work better to respect the mixture structure.

The random methods produce more variability than the original data; this should be possible to control with some weight parameter.

It is visible that quasi-random methods produce jitter noise diagonally from upper-left to bottom-right. This is due to the Sobol sequence. When data is positively correlated, this produces jittering orthogonal to the main direction, but if the correlation is negative, the jittering is aligned with the main direction. This is odd...

```{r}
#| label: fig-bimodal
#| message: false
#| echo: false 
#| warning: false  
#| fig-cap: "Bimodal mixture data"
#| 
exapmle_fn(genff = gendt_bimodal, nn = 100)
```
 
@fig-nonlinear shows results for non-linear data; it is harder to recover the original data structure...

```{r}
#| label: fig-nonlinear
#| message: false
#| echo: false 
#| warning: false 
#| fig-cap: "Non-linear data"
exapmle_fn(genff = gendt_nonlinear, nn = 50)
```


## More interesting cases

Real cases/data scenarios where 2D-jittering is useful/needed: 

-   Survey data scatter plot with subsampling method

-   Age and deaths? Excess deaths in COVID?

- more ??? 



# Discussion

A next step could be to extend this to categorical variables. Use association coefficients instead of correlation?

